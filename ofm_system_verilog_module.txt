//============================================================
// Output Feature Map (OFM) Computation Module
// Example: CNN-style OFM = sum(IFM * WEIGHT) + BIAS
// Fully synthesizable, fixed-point friendly
//============================================================

module ofm_compute #(
    parameter int IFM_W      = 8,    // IFM data width
    parameter int WGT_W      = 8,    // Weight data width
    parameter int ACC_W      = 32,   // Accumulator width
    parameter int KERNEL_SZ  = 9     // e.g., 3x3 kernel
)(
    input  logic                  clk,
    input  logic                  rst_n,

    input  logic                  valid_in,
    input  logic signed [IFM_W-1:0] ifm   [KERNEL_SZ],
    input  logic signed [WGT_W-1:0] weight[KERNEL_SZ],
    input  logic signed [ACC_W-1:0] bias,

    output logic                  valid_out,
    output logic signed [ACC_W-1:0] ofm
);

    // Internal accumulator
    logic signed [ACC_W-1:0] acc;
    integer i;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            acc       <= '0;
            ofm       <= '0;
            valid_out <= 1'b0;
        end else begin
            if (valid_in) begin
                acc = bias;
                for (i = 0; i < KERNEL_SZ; i++) begin
                    acc = acc + (ifm[i] * weight[i]);
                end
                ofm       <= acc;
                valid_out <= 1'b1;
            end else begin
                valid_out <= 1'b0;
            end
        end
    end

endmodule

//============================================================
// SystemVerilog Testbench for OFM Compute
//============================================================

module tb_ofm_compute;

    localparam int IFM_W     = 8;
    localparam int WGT_W     = 8;
    localparam int ACC_W     = 32;
    localparam int KERNEL_SZ = 9; // 3x3

    logic clk;
    logic rst_n;
    logic valid_in;
    logic signed [IFM_W-1:0] ifm   [KERNEL_SZ];
    logic signed [WGT_W-1:0] weight[KERNEL_SZ];
    logic signed [ACC_W-1:0] bias;
    logic valid_out;
    logic signed [ACC_W-1:0] ofm;

    // DUT
    ofm_compute #(
        .IFM_W(IFM_W),
        .WGT_W(WGT_W),
        .ACC_W(ACC_W),
        .KERNEL_SZ(KERNEL_SZ)
    ) dut (
        .clk(clk),
        .rst_n(rst_n),
        .valid_in(valid_in),
        .ifm(ifm),
        .weight(weight),
        .bias(bias),
        .valid_out(valid_out),
        .ofm(ofm)
    );

    // Clock generation
    always #5 clk = ~clk;

    integer i;
    integer golden;

    initial begin
        clk = 0;
        rst_n = 0;
        valid_in = 0;
        bias = 0;

        #20 rst_n = 1;

        // Random test
        repeat (10) begin
            golden = 0;
            bias = $urandom_range(-50, 50);
            golden += bias;

            for (i = 0; i < KERNEL_SZ; i++) begin
                ifm[i]    = $urandom_range(-10, 10);
                weight[i] = $urandom_range(-10, 10);
                golden += ifm[i] * weight[i];
            end

            @(posedge clk);
            valid_in = 1'b1;
            @(posedge clk);
            valid_in = 1'b0;

            wait (valid_out);

            if (ofm !== golden) begin
                $display("ERROR: Expected=%0d, Got=%0d", golden, ofm);
                $fatal;
            end else begin
                $display("PASS: OFM=%0d", ofm);
            end
        end

        $display("All tests PASSED");
        $finish;
    end

endmodule

//============================================================
// PRACTICAL OFM MODULE (Production‑Style)
// Features:
//  - Multi‑channel accumulation (Cin)
//  - Pipelined MAC (1 MAC per cycle)
//  - Ready/Valid handshake
//  - Bias + ReLU + Saturation
//============================================================

module ofm_practical #(
    parameter int IFM_W   = 8,
    parameter int WGT_W   = 8,
    parameter int ACC_W   = 32,
    parameter int CIN     = 16,   // input channels
    parameter int SAT_W   = 16    // output saturation width
)(
    input  logic clk,
    input  logic rst_n,

    // Handshake
    input  logic in_valid,
    output logic in_ready,

    input  logic signed [IFM_W-1:0] ifm,
    input  logic signed [WGT_W-1:0] weight,
    input  logic signed [ACC_W-1:0] bias,

    output logic out_valid,
    input  logic out_ready,
    output logic signed [SAT_W-1:0] ofm
);

    typedef enum logic [1:0] {IDLE, ACCUM, OUT} state_t;
    state_t state;

    logic [$clog2(CIN):0] ch_cnt;
    logic signed [ACC_W-1:0] acc;

    assign in_ready = (state == IDLE) || (state == ACCUM);

    function automatic signed [SAT_W-1:0] sat_relu(input signed [ACC_W-1:0] x);
        signed [SAT_W-1:0] maxv;
        begin
            maxv = {1'b0, {(SAT_W-1){1'b1}}};
            if (x < 0)
                sat_relu = '0;
            else if (x > maxv)
                sat_relu = maxv;
            else
                sat_relu = x[SAT_W-1:0];
        end
    endfunction

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state     <= IDLE;
            acc       <= '0;
            ch_cnt    <= '0;
            out_valid <= 1'b0;
            ofm       <= '0;
        end else begin
            case (state)
                IDLE: begin
                    out_valid <= 1'b0;
                    if (in_valid) begin
                        acc    <= bias + (ifm * weight);
                        ch_cnt <= 1;
                        state  <= (CIN == 1) ? OUT : ACCUM;
                    end
                end

                ACCUM: begin
                    if (in_valid) begin
                        acc    <= acc + (ifm * weight);
                        ch_cnt <= ch_cnt + 1;
                        if (ch_cnt == CIN-1)
                            state <= OUT;
                    end
                end

                OUT: begin
                    if (out_ready) begin
                        ofm       <= sat_relu(acc);
                        out_valid <= 1'b1;
                        state     <= IDLE;
                    end
                end
            endcase
        end
    end

endmodule

/*============================================================
 Python Golden Model (for external verification)
 -------------------------------------------------------------
 import random

 IFM_W = 8
 WGT_W = 8
 KERNEL_SZ = 9

 def ofm_golden(ifm, weight, bias):
     acc = bias
     for i in range(KERNEL_SZ):
         acc += ifm[i] * weight[i]
     return acc

 for _ in range(10):
     ifm = [random.randint(-10,10) for _ in range(KERNEL_SZ)]
     wgt = [random.randint(-10,10) for _ in range(KERNEL_SZ)]
     bias = random.randint(-50,50)
     print(ofm_golden(ifm, wgt, bias))
============================================================*/

//============================================================
// Notes:
// 1. Supports any kernel size (e.g., 3x3, 5x5)
// 2. Can be extended to pipelined MAC array
// 3. Add ReLU / activation after OFM if needed
//============================================================
